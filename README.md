<div align="center">

# ğŸš€ Java DSA Mastery

### *Your Complete Interview Preparation Arsenal*

**125+ battle-tested implementations** | **7 core topics** | **Ready to run**

[Getting Started](#-getting-started) â€¢ [Learning Path](#-learning-path) â€¢ [Interview Prep](#-interview-prep)

---

</div>

## ğŸ¯ What's Inside?

Master data structures and algorithms through hands-on Java implementations. Each file is self-contained with working examples and ready to run.

<table>
<tr>
<td width="50%">

**ğŸŒ³ Trees & Graphs**
- Binary Search Trees (13 files)
- Binary Trees (22 files)  
- Graph Algorithms (23 files)

**ğŸ’¡ Problem Solving**
- Dynamic Programming (28 files)
- Greedy Algorithms (14 files)
- Recursion & Backtracking (12 files)

</td>
<td width="50%">

**ğŸ”¥ Key Features**
- âœ… Zero dependencies
- âœ… Every file has `main()`
- âœ… Clean, documented code
- âœ… Complexity analysis
- âœ… Real interview questions
- âœ… Optimized solutions

</td>
</tr>
</table>

---

## ğŸŒ³ Binary Search Tree
*Master the fundamentals of ordered trees* (13 implementations)

<details>
<summary><b>ğŸ” Click to explore all BST problems</b></summary>

**Core Operations**  
ğŸ” `SearchBST` â€¢ â• `InsertIntoBST` â€¢ âŒ `DeleteNodeInBST` â€¢ ğŸ”„ `BSTIterator`

**Validation & Properties**  
âœ… `ValidateBinarySearchTree` â€¢ ğŸ¯ `KthSmallestElement` â€¢ ğŸ”— `LowestCommonAncestor`

**Range Operations**  
ğŸ“Š `RangeSumBST` â€¢ â¬†ï¸ `FindCeilInBST` â€¢ â¬‡ï¸ `FloorInBST` â€¢ ğŸ² `TwoSumBST`

**Construction & Recovery**  
ğŸ—ï¸ `ConstructFromPreorder` â€¢ ğŸ”§ `RecoverBinarySearchTree`

</details>

---

## ğŸŒ² Binary Tree
*From basics to advanced tree manipulation* (22 implementations)

<details>
<summary><b>ğŸ” Click to explore all Binary Tree problems</b></summary>

**Traversal Techniques**  
â¬…ï¸ `Inorder` â€¢ ğŸ” `Preorder` â€¢ â¬‡ï¸ `Postorder` â€¢ ğŸ“¶ `LevelOrder` â€¢ âš¡ `ZigzagLevelOrder`

**Properties & Metrics**  
ğŸ“ `MaximumDepth` â€¢ ğŸ“ `MinimumDepth` â€¢ ğŸ“ `Diameter` â€¢ âš–ï¸ `Balanced` â€¢ ğŸ“Š `Maxwidth`

**Different Views**  
ğŸ‘€ `TopView` â€¢ ğŸ‘ï¸ `BottomView` â€¢ ğŸ‘‰ `RightSideView` â€¢ ğŸ”² `BoundaryTraversal`

**Tree Comparison**  
ğŸ”„ `SameTree` â€¢ ğŸª `SymmetricTree` â€¢ ğŸ”— `LowestCommonAncestor`

**Construction & Serialization**  
ğŸ—ï¸ `FromPreorderInorder` â€¢ ğŸ—ï¸ `FromInorderPostorder` â€¢ ğŸ—ï¸ `FromPreorderPostorder` â€¢ ğŸ’¾ `SerializeDeserialize`

**Special Problems**  
â¬‡ï¸ `FindBottomLeftTreeValue` â€¢ â±ï¸ `amountOfTime` â€¢ ğŸ”§ `RecoverBST`

</details>

---

## ğŸ’ Dynamic Programming
*Optimization through memoization & tabulation* (28 implementations)

<details>
<summary><b>ğŸ” Click to explore all DP problems</b></summary>

**Foundations**  
ğŸ”¢ `Fibonacci` â€¢ ğŸ”¢ `NthTribonacci` â€¢ ğŸ¸ `FrogJump` â€¢ ğŸ¸ `FrogJumpK`

**House & Grid Problems**  
ğŸ  `HouseRobber` â€¢ ğŸ  `HouseRobberII` â€¢ ğŸ“ `MinPathSum` â€¢ ğŸ¥‹ `NinjaTraining` â€¢ ğŸ—ºï¸ `UniquePaths`

**Subset & Partition**  
ğŸ¯ `SubsetSum` â€¢ âš–ï¸ `PartitionEqualSubsetSum` â€¢ ğŸ”¢ `PartitionsWithGivenDifference` â€¢ ğŸ¯ `PerfectSum` â€¢ ğŸ¯ `TargetSum`

**String Algorithms**  
ğŸ”¤ `LongestCommonSubsequence` â€¢ ğŸ“ `LCSPrint` â€¢ ğŸ”¤ `LongestCommonSubstring` â€¢ ğŸ”¤ `ShortestCommonSupersequence` â€¢ ğŸ”¤ `DistinctSubsequences`

**String Transformations**  
âœï¸ `EditDistance` â€¢ âŒ `DeleteOperationForTwoStrings` â€¢ ğŸ”„ `MinimumInsertionPalindrome`

**Classic Problems**  
ğŸª™ `CoinChange` â€¢ ğŸª™ `CoinChangeII` â€¢ âœ‚ï¸ `RodCutting` â€¢ ğŸ’ `UnboundedKnapsack` â€¢ ğŸ’ `ZeroOneKnapsack` â€¢ ğŸ”¤ `GenerateParentheses`

</details>

---

## ğŸ•¸ï¸ Graph Algorithms
*Master graphs from basics to advanced pathfinding* (23 implementations)

<details>
<summary><b>ğŸ” Click to explore all Graph problems</b></summary>

**Fundamentals**  
ğŸ•¸ï¸ `Graph` â€¢ ğŸ”— `UndirectedStoring` â€¢ â¡ï¸ `DirectedStoring` â€¢ ğŸ“¶ `Bfs` â€¢ ğŸ” `Dfs`

**Cycle Detection**  
ğŸ”„ `DetectCycleInGraph` (DFS) â€¢ ğŸ”„ `DetectCycleKahn` (BFS) â€¢ ğŸ”„ `IsCyclicDirected`

**Graph Properties**  
ğŸ¨ `IsBipartite` â€¢ ğŸŒ `FindCircleNum` â€¢ ğŸ” `PathExistsInGraph`

**Topological Sort**  
ğŸ“‹ `TopoSort` â€¢ ğŸ“š `CourseSchedule` â€¢ ğŸ“š `CourseScheduleII`

**Shortest Path Algorithms**  
ğŸš€ `DijkstraShortestPath` â€¢ âš¡ `BellmanFordAlgorithm` â€¢ ğŸŒ `FloydWarshall` â€¢ ğŸ“ `ShortestPathDAG` â€¢ ğŸ“ `ShortestPathInUnweightedGraph`

**Island & Grid Problems**  
ğŸï¸ `NumIslands` â€¢ ğŸï¸ `CountDistinctIslands` â€¢ ğŸ¨ `FloodFill` â€¢ ğŸŠ `OrangesRotting`

</details>

---

## ğŸ¯ Greedy Algorithms
*Make optimal choices at each step* (14 implementations)

<details>
<summary><b>ğŸ” Click to explore all Greedy problems</b></summary>

**Activity & Interval Problems**  
ğŸ¯ `ActivitySelection` â€¢ ğŸ“… `InsertInterval` â€¢ ğŸ“… `NonOverlappingIntervals`

**Resource Allocation**  
ğŸª `AssignCookies` â€¢ ğŸ¬ `Candy` â€¢ ğŸ‹ `LemonadeChange` â€¢ ğŸš‰ `MinimumPlatforms`

**Jumping & Movement**  
ğŸ¯ `JumpGame` â€¢ ğŸš€ `JumpGameII`

**Scheduling & Meetings**  
ğŸ’¼ `JobSequencingProblem` â€¢ ğŸ¢ `NMeetingsInOneRoom` â€¢ â±ï¸ `MinimumAverageWaitingTime`

**Knapsack & Validation**  
ğŸ’ `FractionalKnapsack` â€¢ âœ… `ValidParenthesisString`

</details>

---

## ğŸ“¦ Heap & Priority Queue
*Efficient min/max operations* (10 implementations)

ğŸ”ï¸ `Heap` (complete implementation) â€¢ ğŸ” `KthLargestElement` â€¢ ğŸ”» `KthSmallestElement` â€¢ ğŸ“Š `KthLargestSubarraySum` â€¢ ğŸ”— `MergeKSortedLists` â€¢ âœ… `CheckBinaryHeap` â€¢ âœ”ï¸ `KSortedArrayCheck` â€¢ ğŸ† `RankTransformOfArray` â€¢ ğŸ”¥ `TopKFrequentElements` â€¢ ğŸ“ `SortCharactersByFrequency`

---

## ğŸ”„ Recursion & Backtracking
*Explore all possibilities intelligently* (12 implementations)

**Subsets & Combinations**  
ğŸ¯ `Subsets` â€¢ ğŸ¯ `SubsetsII` â€¢ ğŸ”€ `PermutationsII` â€¢ ğŸ² `CombinationSum` â€¢ ğŸ² `CombinationSumII`

**String Problems**  
ğŸ“± `LetterCombinations` â€¢ ğŸ”¤ `PalindromePartitioning` â€¢ ğŸ” `CountOccurrencesWord2DArray`

**Classic Puzzles**  
â™› `NQueens` â€¢ â™› `TotalNQueens` â€¢ ğŸ§© `SudokuSolver` â€¢ â• `Sum`


---

## ğŸš€ Getting Started

**Requirements:** Java 8+ and any IDE (VS Code, IntelliJ, Eclipse) or command line

**Quick Run** - Every file has a `main()` method:

```powershell
# Compile and run
javac SearchBST.java
java SearchBST
```

Or just hit **Run** in your IDE. That's it!

---

## ğŸ’¡ Quick Reference

**Time Complexity Cheat Sheet**

| Operation | Array | BST (avg) | Heap | Hash Table |
|-----------|-------|-----------|------|-----------|
| Search    | O(n)  | O(log n)  | O(n) | O(1)      |
| Insert    | O(n)  | O(log n)  | O(log n) | O(1)  |
| Delete    | O(n)  | O(log n)  | O(log n) | O(1)  |

**Common Patterns**
ğŸŒ³ Tree Traversals â€¢ ğŸ‘‰ğŸ‘ˆ Two Pointers â€¢ ğŸ”„ Backtracking â€¢ âœ‚ï¸ Divide & Conquer â€¢ ğŸ§  Dynamic Programming

---

## ğŸ“š Learning Path

```
ğŸŸ¢ START HERE
  â†“
ğŸ”„ Recursion basics (Sum.java, Subsets.java)
  â†“
ğŸŒ² Binary Tree traversals (Inorder, Preorder, Postorder)
  â†“
ğŸŒ³ Binary Search Trees (Search, Insert, Delete)
  â†“  
ğŸ“¦ Heaps & Priority Queues
  â†“
ğŸ•¸ï¸ Graphs (BFS, DFS, Shortest Path)
  â†“
ğŸ’ Dynamic Programming (Fibonacci â†’ Knapsack â†’ Strings)
  â†“
ğŸ¯ Greedy Algorithms & Advanced Backtracking
  â†“
ğŸ”´ INTERVIEW READY!
```

---

## ğŸ¯ Interview Prep

**Most Asked Topics**

ğŸŒ³ **Trees:** LCA, Diameter, Serialize/Deserialize, Validate BST, Kth Smallest  
ğŸ•¸ï¸ **Graphs:** Dijkstra, BFS/DFS, Topological Sort, Islands, Cycle Detection  
ğŸ’ **DP:** LCS, Edit Distance, Knapsack, Coin Change, House Robber  
ğŸ¯ **Greedy:** Intervals, Jump Game, Meeting Rooms, Job Scheduling  
ğŸ”„ **Backtracking:** Subsets, Permutations, N-Queens, Sudoku  
ğŸ“¦ **Heap:** Kth Largest/Smallest, Merge K Lists

**Interview Success Formula**

âœ… Understand the problem thoroughly  
âœ… Think out loud - explain your approach  
âœ… Start with brute force, then optimize  
âœ… Analyze time & space complexity  
âœ… Test with edge cases  
âœ… Write clean, readable code  



---

## ğŸ¤ Contributing

Contributions welcome! Add solutions, optimize code, fix bugs, or improve documentation.

1. Fork the repo
2. Create your branch (`git checkout -b feature/new-algorithm`)
3. Commit changes (`git commit -m 'Add XYZ algorithm'`)
4. Push and open a Pull Request

**Code Style:** camelCase variables, PascalCase classes, meaningful names, document complexity

---

## ğŸ”— Resources

**Practice Platforms:** [LeetCode](https://leetcode.com/) â€¢ [GeeksforGeeks](https://www.geeksforgeeks.org/) â€¢ [HackerRank](https://www.hackerrank.com/)  
**Learn:** [CLRS Textbook](https://en.wikipedia.org/wiki/Introduction_to_Algorithms) â€¢ [YouTube Tutorials](https://www.youtube.com/@takeUforward)

---

<div align="center">

## âœ¨ Why This Repository?

ğŸ’¯ **Production-Ready Code** - Every solution is tested and optimized  
ğŸš€ **Zero Setup** - Just clone and run  
ğŸ“š **Learn by Doing** - Each file is self-contained with examples  
ğŸ¯ **Interview-Focused** - Real questions from top companies  
ğŸ”¥ **125+ Problems** - Covering all major DSA topics

---

### ğŸ’¬ Questions? Found a bug? Want to contribute?
**Open an issue or pull request!**

---

**Made with â¤ï¸ for the coding community**

*Last updated: January 23, 2026*

</div>
